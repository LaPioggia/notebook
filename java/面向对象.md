## 目录
[一、引用](#一引用)<br/>
[二、存储位置](#二存储位置)<br/>
[三、作用域](#三作用域)<br/>
[四、类](#四类)<br/>
[五、初始化](#五初始化)<br/>
[六、关键字](#六关键字)<br/>
[七、清理](#七清理)<br/>
[三、作用域](#三作用域)<br/>

### 一、引用
1. 操纵的标识符实际上是对象的一个引用
2. 拥有一个引用，并不一定需要有一个对象与它关联
3. 只创建了一个引用，而非对象，会返回一个运行时错误。
4. 一个安全的做法是，创建一个引用的同时便进行初始化
5. 字符串可用带引号的文本初始化
   ```java
   String s = "asdf";
   ```
6. 通常使用new操作符，将一个新的对象与引用相关联
### 二、存储位置
1. 寄存器
   速度最快，位于处理器内部。根据需求进行分配，不能直接控制。
2. 堆栈
   位于通用RAM（随机访问存储器）中，通过堆栈指针可从处理器那里获得直接支持。堆栈指针向下移动，分配新的内存；向上移动，释放内存。效率仅次于寄存器。在创建程序时，java必须知道存储在堆栈内所有项的确切生命周期，以便上下移动堆栈指针。<br/>基本类型存放于堆栈中
3. 堆
   一种通用的内存池，位于RAM区，存放所有java对象。不同于堆栈的是，编译器不需要知道存储的数据在堆里存活的时间，因此具有很大的灵活性。用堆进行存储分配和清理需要更多时间。
4. 常量存储
   直接存放在程序代码内部（？）
5. 非RAM存储
   数据完全存活于程序之外，不受程序的任何控制，在程序没有运行时也存在。如流对象和持久化对象。
### 三、作用域
1. 变量作用域：由花括号的位置决定
2. 对象的作用域
   java对象可以存活于作用域之外，通过垃圾回收器来监视用new创建的所有对象并辨别那些不会再被引用的对象，随后释放
### 四、类
1. 决定类某一类对象的外观与行为
2. 包含两类元素：字段（数据成员），方法（成员函数）
   1. 字段
      可以是任意类型的对象，可通过其引用与其进行通信。<br/>如果字段是对某个对象的引用，那么必须初始化该引用，以便使其与一个实际的对象相关联.<br/>如果类的某个成员是*基本数据类型*，即使没有进行初始化，java也会确保它获得一个默认值。（此确保初始化的方法并不适用于局部变量）
   1. 方法
      1. 重载：方法名相同，参数列表不同；<br/>方法接受较小的基本类型作为参数
3. static关键字
   当声明一个事物是static时，就意味着这个域或方法不会与包含它的那个类的任何对象实例关联在一起
### 五、初始化
1. 构造器
   在创建对象时，会为对象分配存储空间，并调用相应的构造器，确保对象得到初始化；<br/>构造器的名称必须与类名相同，无返回值；<br/>构造器强制重载方法名；<br/>类中默认一个无参构造，若已定义了一个构造器，就不会自动创建无参构造<br/>无法阻止自动初始化的进行，它将在构造器被调用之前发生
2. 成员初始化
   1. java尽力保证所有变量在使用前都能得到恰当的初始化，对于方法的局部变量，java以编译时错误的形式来贯彻这种保证
### 六、关键字
1. this
   为了能用简便、面向对象的语法来编写代码，编译器暗自把“所操作对象的引用”作为第一个参数传递给方法。若希望在方法的内部获得对当前对象的引用，可以使用关键字this。<br/>this关键字只能在方法内部使用，但若在方法内部调用同一个类的另一个方法，就不必使用this，this引用会自动应用于同一类的其他方法。<br/>使用this关键字可在一条语句中对同一个对象执行多次操作，以及将当前对象传递给其他方法，在构造器中调用构造器，但该调用必须位于首行。
   ``` java
   public class leaf {
      int i = 0;
      Leaf increment() {
         i++;
         return this;
      }

      void print() {
         System.out.println("i = " + i);
      }

      public static void main(String args[]) {
         Leaf x = new Leaf();
         x.increment().increment().increment().print();
      }
   }
   ```
2. static
   无this的方法，可通过类本。<br/>static方法内部不能调用非静态方法
### 七、清理
1. finalize()
   垃圾回收只会释放经由new分配的内存，无法释放其他情况下的内存，因此允许定义该方法。<br/>一旦垃圾回收器准备好释放对象占用的存储空间，将首先调用其finalize()方法，并在下一次垃圾回收动作发生时，才会真正回收对象所占用的内存。<br/>C++中，对象一定会被销毁，java里的对象并非总是被垃圾回收，即垃圾回收不等于析构。<br/>java并未提供析构函数或类似的概念，要做类似的清理工作，必须自己创建一个执行清理工作的普通方法<br/>之所以会有finalize()方法，是由于在分配内存时可能采用类类似C语言中的做法，主要发生在使用本地方法的情况下
2. 垃圾回收
   1. 垃圾回收只于内存有关，无论对象是如何创建的，垃圾回收器都会负责释放对象占据的所有内存
   2. System.gc()用于强制进行终结动作
   3. 垃圾回收器在工作的时候，将一面回收空间，一面使堆中的对象紧凑排列，这样堆指针就可以很容易移动到更靠近传送带的开始处，也就尽量避免了页面错误。通过垃圾回收器对对象重新排列，实现类一种高速的，有无限空间可供分配的堆模型
   4. java虚拟机采用一种自适应的垃圾回收技术，具体取决于不同java虚拟机的实现。<br/>一种做法名为停止-复制（不属于后台回收模式），即先暂停程序的运行，然后将所有存活的对象从当前堆复制到另一个堆，没有被复制的全部都是垃圾。<br/>当把对象从一处搬到另一处时，所有指向它的那些引用都必须修正，位于堆或静态存储区的引用可以直接修正，其他的需要在遍历的过程中才能被找到。<br/>这种“复制式回收器”效率较低，原因在于：需要两个堆，维护较实际多一倍的空间；程序进入稳定状态后，可能只会产生少量垃圾，甚至没有垃圾，但复制回收器仍会将所有内存自一处复制到另一处，造成浪费，一些java虚拟机会进行检查，如果没有新垃圾产生，则转入标记-清扫模式；<br/>标记-清扫：从堆栈和静态存储区出发，遍历所有的引用，进而找出所有存活的对象。每当它找到一个存活对象，就给对象一个标记，当全部标记完成时，释放所有没有标记的对象，不会发生任何复制动作。这样剩下的堆空间是不连续的，垃圾回收器为得到连续空间，需要重新整理剩下的对象。必须在程序暂停的情况下进行。<br/>java虚拟机中，内存分配以较大的块为单位，垃圾回收器在回收的时候可以向废弃的块里拷贝对象。每个块用相应的代数来记录它是否还存活。java虚拟机会进行监视，如果所有对象都很稳定，垃圾回收器效率降低就切换到标记-清扫模式，若堆空间出现很多碎片，就会切换回停止-复制方式
3. 其他系统的垃圾回收机制
   1. 引用计数：简单但速度很慢<br/>每个对象都含有一个引用计数器，当有引用连接至对象时，引用计数加1，当引用离开作用域或被置为null时，引用计数减1，此项开销会在整个程序生命周期中持续发生。垃圾回收器会在含有全部对象的列表上遍历，释放引用计数为0的对象的空间。若对象之间存在循环引用时，可能会出现对象应该被回收，但引用计数却不为零的情况。
   2. 从堆栈和静态存储区开始，遍历所有引用，对于发现的每个引用，必须追踪它所引用的对象，然后是此对象包含的所有引用，如此反复进行，直到根源于堆栈和静态存储区的引用所形成的网络全部被访问为止，访问过的对象一定都是活的
4. 即使（JIT）编译器计数：将程序全部或部分翻译成本地机器码<br>当需要装载某个类时，编译器会找到其.class文件，然后将该类的字节码装入内存。此时，有两种方案：<br/>1.让即时编译器编译所有代码，这种加载动作散落在整个程序生命周期内，累加起来要话更多时间，且会增加可执行代码的长度（字节码要比即时编译器展开后的本地机器码小很多），这将导致页面调度，从而降低程序速度；2.惰性评估：即时编译器只在必要的时候才编译代码。新版JDK中的Java HotSpot技术就采用了类似方法，代码每次被执行的时候都会做一些优化，所以执行的次数越多，它的速度越快。