### 面试基础
#### 1. jdk与jre区别
#### 2. java编译方式
#### 3. ==与equals区别
== ：对于基本数据类型来说，比较的是值，对于引用数据类型来说，比较的是对象的内存地址<br/>equals()：通过重写，比较两个对象中的属性是否相等(若未覆盖，等价于==)<br/>**说明**<br/>1.String中的equals()比较对象的值；<br/>2.hashCode()；<br/>3.Object的equals方法容易抛空指针异常，应使用常量或确定有值的的对象来调用<br/>4.所有整型包装类对象值的比较必须使用equals()方法
#### 4. 基本数据类型及大小（字节）
数字类型：byte(1),short(2),int(4),long(8),float(4),double(8);<br/>字符类型：char(2);<br/>布尔类型：boolean(1bit)<br/>基本数据类型及对象引用存放于java虚拟机栈的局部变量表中<br/>自动装箱与拆箱：装箱实际调用了包装类的valueOf()方法，拆箱调用了xxxValue()方法。<br/>包装类与常量池<br/>所以整形包装类对象之间值的比较，全部使用equals()。
#### 5. 静态方法
1. 在静态方法中调用非静态成员非法。<br/>静态方法是属于类的，在类加载时就会分配内存，可以通过类名直接访问，而非静态成员属于实例对象，只有在对象实例化之后才存在，然后通过类的实例对象去访问。在类的非静态成员不存在时，静态成员就已经存在了，此时调用内存中还不存在的非静态成员属于非法操作。
2. 调用方式<br/>调用静态方法无需创建对象，一般使用*类名.方法名*的方式调用。
3. 只可访问静态成员。
#### 6. 参数传递
1. 按值调用(call by value)：方法接收的是调用者提供的值；
2. 按引用调用(call bt reference)：方法接收的是调用者提供的变量地址。
java总是采用按值调用，方法得到的是所有参数值的一个拷贝，不能修改传递给它的任何参数变量的内容
#### 7. 重载和重写
1. 重载
   发生在同一个类中（或父类与子类之间），方法名必须相同，参数类型，个数，顺序不同，返回值和访问修饰符随意；<br/>编译期，同一类中多个同名方法根据不同的传参来执行不同的逻辑处理；
2. 重写
   返回值类型，方法名，参数列表必须相同，抛出的异常范围小于父类，访问修饰符类型大于父类；<br/>无法重写父类访问修饰符为private/final/static的方法；<br/>构造方法不能重写；<br/>static修饰的方法能够再次声明；<br/>是运行期，子类对父类方法的重新构造。
#### 8.拷贝
1. 浅拷贝
   对基本数据类型进行值传递，对引用数据类型进行引用传递的拷贝；
2. 深拷贝
   对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容
#### 9. 面向对象
1. new创建对象实例，对象引用指向对象实例；
2. 对象实例存放于堆内存中， 对象引用存放于栈内存中；
3. 面向对象三大特征：封装，继承，多态
#### 10. 构造方法
1. 作用：完成对类对象的初始化工作
2. 默认带一个无参构造
3. 特点：
   1. 名字与类相同；
   2. 无返回值
   3. 生成类对象时自动执行
   4. 不可被重写，但可被重载
#### 11. String、StringBuilder
String类使用final关键字修饰：private final char value[]；
java9后，改用private final byte[] value；
StringBuilder和StringBuffer都继承自AbstractStringBuilder类；
String中对象为不可变的，线程安全；StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，线程安全，StringBuilder非线程安全；
每次对String类型进行改变时，都会产生一个新的String对象，然后将指针指向新的String对象
#### 12. 异常
所有异常都继承于java.lang包中的Throwable类；
1. Exception：程序可处理的异常，可通过catch捕获。可分为受检查异常（必须处理）和不受检查异常（可以不处理）；
2. Error：程序无法处理的错误
3. try-with-resources
#### 13. IO流
1. 序列化：需要持久化java对象<br/>将数据结构或对象转换成字节流的过程
2. transient：阻止实例中用此关键字修饰的变量序列化，当对象被反序列化时，该变量值不会被持久化和恢复。<br/>只能修饰变量；<br/>修饰的变量，在反序列化后变量值将会被置为类型的默认值；<br/>static变量不会被序列化。
3. 分类
   1. 输入流，输出流
   2. 字节流，字符流
   3. 节点流，处理流
#### 14. 键盘输入
1. Scanner
2. BufferReader
#### 15. BigDecimal
1. 为防止精度丢失，推荐使用BigDecimal(String)构造方法来创建对象；
#### 16. 枚举
以这种方式定义的常量使代码更具可读性，允许进行编译时检查，预先记录可接受值的列表，并避免由于传入无效值而引起的意外行为；<br/>
可以使用==比较<br/>
*EnumSet：*
1.使用内部位向量表示，是特定Enum常量集的非常有效且紧凑的表示形式；
2.提供类型安全的替代方法，以替代传统的基于int的位标志；
3.抽象类，提供两个实现：RegularEnumSet,JumboEnumSet;
*EnumMap*
1.用于将枚举常量用作键
#### 17. 关键字
1. final
   1. 修饰类，方法，变量；
   2. 类不能被继承，所有成员方法都会被隐式指定为final方法；
   3. 方法不能重写；
   4. 变量为常量
2. static
   1. 成员变量和成员方法：被static修饰的成员属于类，被类中所用成员共享，建议通过类名调用；成员变量属于静态成员变量，存在于java内存区域的方法区；<br/>方法区是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据
   2. 静态代码块：定义在类中方法外，只执行一次；（静态代码块->非静态代码块->构造方法）
   3. 静态内部类（static修饰类只能修饰内部类）：创建不需要依赖外围类的创建，不能使用任何外围类的非static成员变量和方法；<br/>非静态内部类在编译完成后会保存一个引用，该引用指向创建它的外围类，静态内部类没有；
   4. 静态导包：import static
3. this
   1. 用于引用类的当前实例；
   2. 不能使用于static方法中；
   3. 调用其他构造方法时，必须位于首行
4. super
   1. 从子类访问父类的变量和方法；
   2. 不能使用于static方法中；
   3. 必须位于构造器首行