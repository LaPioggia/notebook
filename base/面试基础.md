### 面试基础
#### 1. jdk与jre区别
#### 2. java编译方式
#### 3. ==与equals区别
== ：对于基本数据类型来说，比较的是值，对于引用数据类型来说，比较的是对象的内存地址<br/>equals()：通过重写，比较两个对象中的属性是否相等(若未覆盖，等价于==)<br/>**说明**<br/>1.String中的equals()比较对象的值；<br/>2.hashCode()；<br/>3.Object的equals方法容易抛空指针异常，应使用常量或确定有值的的对象来调用<br/>4.所有整型包装类对象值的比较必须使用equals()方法
#### 4. 基本数据类型及大小（字节）
1. 数字类型(字节)：byte(1),short(2),int(4),long(8),float(4),double(8);<br/>字符类型：char(2);<br/>布尔类型：boolean(1bit)
2. 基本数据类型及对象引用存放于java虚拟机栈的局部变量表中
3. 自动装箱与拆箱：装箱实际调用了包装类的valueOf()方法，拆箱调用了xxxValue()方法。
4. 包装类与常量池
5. 整形包装类对象之间值的比较，全部使用equals()。
6. Integer的范围在[-128,127]会被缓存，在这个范围内比较大小，相等为true，超过范围为false
#### 5. 静态方法
1. 在静态方法中调用非静态成员非法。<br/>静态方法是属于类的，在类加载时就会分配内存，可以通过类名直接访问，而非静态成员属于实例对象，只有在对象实例化之后才存在，然后通过类的实例对象去访问。在类的非静态成员不存在时，静态成员就已经存在了，此时调用内存中还不存在的非静态成员属于非法操作。
2. 调用方式<br/>调用静态方法无需创建对象，一般使用*类名.方法名*的方式调用。
3. 只可访问静态成员。
#### 6. 参数传递
1. 按值调用(call by value)：方法接收的是调用者提供的值；
2. 按引用调用(call bt reference)：方法接收的是调用者提供的变量地址。
java总是采用按值调用，方法得到的是所有参数值的一个拷贝，不能修改传递给它的任何参数变量的内容
#### 7. 重载和重写
1. 重载
   发生在同一个类中（或父类与子类之间），方法名必须相同，参数类型，个数，顺序不同，返回值和访问修饰符随意；<br/>编译期，同一类中多个同名方法根据不同的传参来执行不同的逻辑处理；
2. 重写
   返回值类型，方法名，参数列表必须相同，抛出的异常范围小于父类，访问修饰符类型大于父类；<br/>无法重写父类访问修饰符为private/final/static的方法；<br/>构造方法不能重写；<br/>static修饰的方法能够再次声明；<br/>是运行期，子类对父类方法的重新构造。
#### 8.拷贝
1. 浅拷贝
   对基本数据类型进行值传递，对引用数据类型进行引用传递的拷贝；
2. 深拷贝
   对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容
#### 9. 面向对象
1. new创建对象实例，对象引用指向对象实例；
2. 对象实例存放于堆内存中， 对象引用存放于栈内存中；
3. 面向对象三大特征：封装，继承，多态
#### 10. 构造方法
1. 作用：完成对类对象的初始化工作
2. 默认带一个无参构造
3. 特点：
   1. 名字与类相同；
   2. 无返回值
   3. 生成类对象时自动执行
   4. 不可被重写，但可被重载
#### 11. String、StringBuilder
String类使用final关键字修饰：private final char value[]；
java9后，改用private final byte[] value；
StringBuilder和StringBuffer都继承自AbstractStringBuilder类；
String中对象为不可变的，线程安全；StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，线程安全，StringBuilder非线程安全；
每次对String类型进行改变时，都会产生一个新的String对象，然后将指针指向新的String对象
#### 12. 异常
所有异常都继承于java.lang包中的Throwable类；
1. Exception：程序可处理的异常，可通过catch捕获。可分为受检查异常（必须处理）和不受检查异常（可以不处理）；
2. Error：程序无法处理的错误
3. try-with-resources
#### 13. IO流
1. 序列化：需要持久化java对象<br/>将数据结构或对象转换成字节流的过程
2. transient：阻止实例中用此关键字修饰的变量序列化，当对象被反序列化时，该变量值不会被持久化和恢复。<br/>只能修饰变量；<br/>修饰的变量，在反序列化后变量值将会被置为类型的默认值；<br/>static变量不会被序列化。
3. 分类
   1. 输入流，输出流
   2. 字节流，字符流
   3. 节点流，处理流
#### 14. 键盘输入
1. Scanner
2. BufferReader
#### 15. BigDecimal
1. 为防止精度丢失，推荐使用BigDecimal(String)构造方法来创建对象；
#### 16. 枚举
以这种方式定义的常量使代码更具可读性，允许进行编译时检查，预先记录可接受值的列表，并避免由于传入无效值而引起的意外行为；<br/>
可以使用==比较<br/>
*EnumSet：*
1.使用内部位向量表示，是特定Enum常量集的非常有效且紧凑的表示形式；
2.提供类型安全的替代方法，以替代传统的基于int的位标志；
3.抽象类，提供两个实现：RegularEnumSet,JumboEnumSet;
*EnumMap*
1.用于将枚举常量用作键
#### 17. 关键字
1. final
   1. 修饰类，方法，变量；
   2. 类不能被继承，所有成员方法都会被隐式指定为final方法；
   3. 方法不能重写；
   4. 变量为常量
2. static
   1. 成员变量和成员方法：被static修饰的成员属于类，被类中所用成员共享，建议通过类名调用；成员变量属于静态成员变量，存在于java内存区域的方法区；<br/>方法区是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据
   2. 静态代码块：定义在类中方法外，只执行一次；（静态代码块->非静态代码块->构造方法）
   3. 静态内部类（static修饰类只能修饰内部类）：创建不需要依赖外围类的创建，不能使用任何外围类的非static成员变量和方法；<br/>非静态内部类在编译完成后会保存一个引用，该引用指向创建它的外围类，静态内部类没有；
   4. 静态导包：import static
3. this
   1. 用于引用类的当前实例；
   2. 不能使用于static方法中；
   3. 调用其他构造方法时，必须位于首行
4. super
   1. 从子类访问父类的变量和方法；
   2. 不能使用于static方法中；
   3. 必须位于构造器首行
#### 18. 反射
#### 19. 正则表达式
1. String类提供了支持正则表达式操作的方法，此外，还可用Pattern类表示正则表达式对象
#### 20. Iterator
Iterator支持从源集合中安全地删除对象，只需在Iterator上调用remove()即可。这样做的好处是可以避免ConcurrentModifiedException，当打开Iterator迭代集合时，同时又在对集合进行修改。有些集合不允许在迭代时删除或添加元素，但是调用Iterator的remove()方法是个安全的做法。
#### 21. http错误
1. 404-未找到，服务器找不到所请求的网页；
2. 302-临时移动，服务器从不同的位置响应请求；
3. 500-服务器内部错误
4. 403-服务器拒绝请求
#### 22.cookie
1. 默认失效时间是直到关闭浏览器，也可通过expires指定时间；
2. domain属性可使多个web服务器共享cookie，其默认值是创建cookie的网页所在服务器的主机名，不能将一个cookie的域设置为服务器所在的域之外的域；
3. path指定与cookie关联在一起的网页。默认情况下，cookie会与创建它的网页，该网页出于同一目录下的网页以及这个网页所在目录下的子目录下的网页关联；
4. secure，布尔值，指定网络上如何传输cookie，默认是不安全的，通过一个普通的http连接传输；如果secure被作为SetCookie头的一部分，那么cookie只能通过安全通道传输（目前即SSL通道）
5. 用来记录用户信息，表明用户身份
#### 23. 线程
1. synchronized关键字：为对象、方法、代码块加锁，对对象加互斥锁；
2. volatile关键字：用来确保变量的更新操作通知到其他线程，但不会执行加锁操作
#### 24. UML图
1. 用例图
2. 类图
3. 对象图
4. 包图
5. 活动图
6. 状态图
7. 序列图
8. 协作图
9. 构件图
10. 部署图
#### 25. JVM堆
1. 新生代：一般是一个Eden区，两个Survivor区
2. 老年代：old区
#### 26. 内部类
1. 局部内部类：放在代码块或方法中的，不能由public,protected,private,static修饰
#### 27. 抽象类
1. JDK 1.8以前，抽象类的方法默认访问权限为protected<br/>JDK 1.8时，抽象类的方法默认访问权限变为default